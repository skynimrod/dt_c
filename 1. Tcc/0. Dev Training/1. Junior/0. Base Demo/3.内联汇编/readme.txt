参见:

    https://baike.baidu.com/item/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/3183809?fr=aladdin

    https://www.cnblogs.com/rain-blog/p/gnu-gcc-insert-asm.html

    https://www.cnblogs.com/taek/archive/2012/02/05/2338838.html

参见:

     https://www.cnblogs.com/rain-blog/p/gnu-gcc-insert-asm.html      GNU  C 的内联汇编介绍

. 内联汇编，指在C语言中插入汇编语言，其是Linux中使用的基本汇编程序语法。

  Tcc 中如下格式使用

    static inline void aprintf( char  * buf )
    {
	    asm( "mov dx, buf");
            return;
    }

    注意， 一定不要少了inline, 不然编译通不过, 不认识汇编指令.

1.file_tools/file_tools.c:66: error: unknown opcode 'movd'
NMAKE : fatal error U1077: 'tcc' : return code '0x1'
Stop.

============

static inline void * my_memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
        "rep ; movsl\n\t"
        "testb $2,%b4\n\t"
        "je 1f\n\t"
        "movsw\n"
        "1:\ttestb $1,%b4\n\t"
        "je 2f\n\t"
        "movsb\n"
        "2:"
        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
        :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
        : "memory");
return (to);
}

====================== 这个可以

gcc 内联汇编

. __asm__("汇编指令1\n\t"
        "汇编指令2\n\t"
        "汇编指令3\n\t"
        "汇编指令n"
        : 输出变量列表
        : 输入变量列表
        : 被破坏的寄存器列表);

汇编指令

1、在 __asm__(); 的“”中，便是编写汇编指令的地方。利用 C 语言自动连接双引号的特性，我们可以像框架那样每一行只写一条指令，当然你也可以全部写在一行，那么需要用 ';' 将不同的指令分开。

2、\n 用于指令换行，\t使 GCC 编译的时候产生的汇编指令格式保持规范。
GCC 默认使用 AT&T 格式的汇编语法 它与 intel 的汇编语法之间稍有不同。简单说两点不同的地方：

    AT&T 汇编在操作寄存器时需要在前面加一个 '%' 符号，而 intel 的不用。由于在 C 代码中嵌入汇编时，写在字符串中，由于 '%' 在 C 语言中是特殊字符，所以为什么在第一个例子中寄存器前加了两个 '%'.
    AT&T 在操作立即数时，需要在立即数前面加 '$'，而 intel 却是 '#'.
    AT&T 的源与目的与 intel 相反。例如： intel:mov eax, #1 AT&T:movl $1, %eax.

3、这里只是提到了本文中会见到的一部分差异，更多具体关于 AT&T 汇编的知识，这里就不再赘述。可参见相关描述 AT&T 汇编的书籍。


输出变量列表

1、输出变量列表是描述，在内嵌的汇编指令中将哪些值输出到 C 代码环境中的哪个变量中。比如第一个例子中我们指定在执行完了所写的汇编指令后将 eax 寄存器的值输出到变量 y 中。
其中 "=a" 指明使用 eax 寄存器为输出寄存器，输出到紧跟的变量 (y) 中。

    = 代表输出变量用作输出，原来的值会被新值替换。
    + 代表即可用作输入，也可用作输出。

2、输出变量列表可以写多个变量，每个之间使用逗号隔开。例如:： “=a” (x), "=b" (y), "=r" (z)。其中用到的 a, b 等代表相应的寄存器。如下是一部分对应关系。



代码 	含义
a 	使用寄存器 eax
b 	使用寄存器 ebx
c 	使用寄存器 ecx
d 	使用寄存器 edx
S 	使用 esi
D 	使用 edi
q 	使用动态分配字节可寻址寄存器
r 	使用任意动态分配的寄存器
A 	使用寄存器 eax 与 edx 联合
m 	使用内存地址
o 	使用内存地址并可以加偏移量
I 	使用常数 0-31
J 	使用常数 0-63
K 	使用常数 0-255
M 	使用常数 0-3
N 	使用一字节常数 0-255

3、这里仅仅列出了一部分常用到的代码，更多详细请参考 GNU C 的 GCC 使用手册。
这里讲一下 "=r" 的用法，像 a, b 这些代码都是指定使用的寄存器。但是 r 是让编译器随机给一个，那么我怎么知道是那个呢？
不用担心，编译器为使用的随机寄存器遍了一个号。规则是：从输出列表开始，一直到输入列表结束，从左到右，从上到下一次为 %0, %1, %2....所以我们可以这样改写第一个代码例子：

#include <stdio.h>

int main(int argc, char *argv[])
{
    int x = 3, y = 4;

    __asm__("addl %1, %0"
        : "=r" (y)
        : "r" (x), "0" (y));
    
    printf("x + y = %d\n", y);
    return 0;
}

输入变量列表

1、和输出变量列表一样，使用的寄存器代码依然一样的含义。只是少了 '=' 而已。注意如果一个变量使用 'r' 代码时，既做输出，又做输入的话，在写输入变量对应的寄存器时，就写它在输出列表里对应的编号。如上一个例子中 y 既做输出又做输入，那么刚进入汇编指令时，%0的值便为 y 之前的值 4 ，指令结束后 %0 为 7 , 接着又把 %0 输出到了 y 。
破坏寄存器列表

1、这一行告诉 GCC 在内联的汇编代码中，哪些寄存器可能会被使用到（显式/隐式）。那么 GCC 就会在进入内联汇编之前将这些寄存器保存起来，最后再恢复。避免影响到其他的代码。
早期的 GCC 要求把输入、输出用到的寄存器写到破坏列表里面。但是现在的编译器能够自动保存、恢复在输出、输入列表里面用到的寄存器。因此上述的例子中由于没有影响到其他非输出、非输入的寄存器，所以可以省略破坏列表。